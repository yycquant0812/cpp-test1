/* ========================================
   最大公因數 (GCD) - 迴圈實作
   ========================================
   最大公因數定義：
   能同時整除兩個整數的最大正整數

   範例：
   GCD(12, 8) = 4
   因為 12 = 4×3, 8 = 4×2
   4 是能同時整除 12 和 8 的最大數

   歐幾里得演算法 (Euclidean Algorithm)：
   GCD(m, n) = GCD(n, m mod n)
   持續用較小的數和餘數替換，直到餘數為 0

   演算法步驟：
   1. 計算 m 除以 n 的餘數 r
   2. 如果 r = 0，則 GCD = n
   3. 如果 r ≠ 0，則將 m 設為 n，n 設為 r，重複步驟 1

   範例：GCD(48, 18)
   48 = 18 × 2 + 12  → GCD(18, 12)
   18 = 12 × 1 + 6   → GCD(12, 6)
   12 = 6 × 2 + 0    → GCD(6, 0) = 6

   此程式使用「迴圈」實作
   ======================================== */

#include<iostream>
using namespace std;

// 函式原型宣告：計算最大公因數 (迴圈版本)
int gcd(int, int);

int main() {
    int m;
    int n;

    // 提示使用者輸入兩個整數
    cout << "輸入兩數：";
    cin >> m >> n;

    // 呼叫 GCD 函式並輸出結果
    cout << "GCD: " << gcd(m, n) << endl;

    return 0;
}

/* ========================================
   函式名稱：gcd
   功能：使用迴圈方式計算最大公因數
   參數：
     m - 第一個整數
     n - 第二個整數
   回傳值：m 和 n 的最大公因數

   演算法：歐幾里得演算法 (迴圈實作)

   執行過程範例：計算 GCD(48, 18)

   初始值：m = 48, n = 18

   第1次迴圈：
   r = 48 % 18 = 12
   m = 18
   n = 12

   第2次迴圈：
   r = 18 % 12 = 6
   m = 12
   n = 6

   第3次迴圈：
   r = 12 % 6 = 0
   m = 6
   n = 0

   迴圈結束 (n = 0)
   回傳 m = 6

   演算法正確性證明：
   若 d 能整除 m 和 n，
   則 d 也能整除 (m - k×n)，其中 k 是整數
   因此 GCD(m, n) = GCD(n, m mod n)

   時間複雜度：O(log(min(m, n)))
   空間複雜度：O(1)

   迴圈 vs 遞迴比較：
   - 迴圈版本：節省記憶體空間，不會堆疊溢位
   - 遞迴版本：程式碼更簡潔，更接近數學定義
   ======================================== */
int gcd(int m, int n) {
    int r;

    // 當 n 不為 0 時，持續執行迴圈
    while(n != 0) {
        // 計算 m 除以 n 的餘數
        r = m % n;

        // 將 n 的值指派給 m
        m = n;

        // 將餘數 r 指派給 n
        n = r;
    }

    // 當 n = 0 時，m 就是最大公因數
    return m;
}
