/* ========================================
   排列組合數計算程式 - 遞迴實作
   ========================================
   組合數定義：
   從 n 個相異物品中取出 r 個的組合數

   公式：C(n,r) = n! / (r! × (n-r)!)

   遞迴公式：
   C(n,0) = 1  (取0個只有1種方法)
   C(n,n) = 1  (全取只有1種方法)
   C(n,r) = C(n-1,r-1) + C(n-1,r)

   遞迴公式的意義：
   把第n個物品分成「取」或「不取」兩種情況
   - 如果取第n個：剩下需要從前n-1個取r-1個 → C(n-1,r-1)
   - 如果不取第n個：需要從前n-1個取r個 → C(n-1,r)
   ======================================== */

#include <iostream>
using namespace std;

// 函式原型宣告：計算階乘
int factorial(int);

// 函式原型宣告：計算組合數 (使用遞迴方法)
int C(int,int);

int main(void)
{
    int n, r;

    // 提示使用者輸入 n 和 r
    cout<<"計算組合數C, 請輸入n,r:";
    cin>>n>>r;

    // 檢查輸入是否有效
    if (r > n || r < 0 || n < 0)
    {
        cout<<"錯誤：請確保 0 <= r <= n"<<endl;
        return 1;
    }

    // 呼叫函式計算並輸出結果
    cout<<"C("<<n<<","<<r<<") = "<<C(n,r)<<endl;

    return 0;
}

/* ========================================
   函式名稱：factorial
   功能：計算階乘 n!
   參數：n - 要計算階乘的數字
   回傳值：n! 的值

   此函式用於輔助說明組合數的數學公式
   ======================================== */
int factorial(int n)
{
    if (n == 0 || n == 1)
        return 1;
    return n * factorial(n - 1);
}

/* ========================================
   函式名稱：C
   功能：使用遞迴方式計算組合數 C(n,r)
   參數：
     n - 總物品數
     r - 要取出的物品數
   回傳值：組合數的值

   遞迴實作方式：
   1. 基底條件 (Base Case)：
      - C(n,0) = 1：不取任何物品，只有1種方法
      - C(n,n) = 1：全部取出，只有1種方法

   2. 遞迴條件 (Recursive Case)：
      C(n,r) = C(n-1,r-1) + C(n-1,r)

   範例：計算 C(4,2)
   C(4,2) = C(3,1) + C(3,2)
          = [C(2,0) + C(2,1)] + [C(2,1) + C(2,2)]
          = [1 + C(1,0) + C(1,1)] + [C(1,0) + C(1,1) + 1]
          = [1 + 1 + 1] + [1 + 1 + 1]
          = 3 + 3
          = 6

   數學驗證：C(4,2) = 4!/(2!×2!) = 24/(2×2) = 6 ✓

   優點：程式碼簡潔，容易理解遞迴邏輯
   缺點：當 n 較大時，會有重複計算，效率較低

   巴斯卡三角形 (Pascal's Triangle) 原理：
        n=0:           1
        n=1:         1   1
        n=2:       1   2   1
        n=3:     1   3   3   1
        n=4:   1   4   6   4   1

   每個數字都是上方兩個數字的和，這正是遞迴公式的幾何意義
   ======================================== */
int C(int n, int r)
{
    // 基底條件 1：取0個物品，只有1種方法
    if (r == 0)
        return 1;

    // 基底條件 2：取全部物品，只有1種方法
    if (r == n)
        return 1;

    // 遞迴條件：將問題分解為兩個子問題
    // 第n個物品「取」或「不取」的情況總和
    return C(n-1, r-1) + C(n-1, r);
}
